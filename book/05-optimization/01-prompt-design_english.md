# 5.1 Principles of Effective Prompt Design

## Introduction

In AITDD, the quality of the AI's output largely depends on prompt design. With proper prompt design, you can improve the quality of AI-generated code and maximize development efficiency. In this chapter, we will learn the principles and specific methods of practical prompt design.

## Basic Principles of Prompt Design

### 1. Adopting an Iterative Improvement Method

In AITDD, instead of aiming for a perfect result with a single prompt creation, we design with the premise of continuous improvement.

**Basic Cycle:**
```
Create Prompt â†’ Execute â†’ Evaluate Result â†’ Correct â†’ Rerun
```

**Key Points for Practice:**
- Aim for 80% quality on the first try and don't seek perfection.
- Analyze each execution result in detail to identify areas for improvement.
- Aim for optimization by accumulating small corrections.
- Record improvement logs to grasp patterns.

### 2. Incorporating Confidence Level Evaluation

By having the AI evaluate its confidence in its own output, you can efficiently identify the parts that need to be reviewed.

**Confidence Indicators:**
- **ðŸŸ¢ High Confidence**: Can be clearly derived from the reference files.
- **ðŸŸ¡ Medium Confidence**: Based on reasonable inference but requires confirmation.
- **ðŸ”´ Judgment Required**: Generated by independent judgment and requires focused confirmation.

### 3. Step-by-step Customization

Optimize the prompt for each step of TDD (Red, Green, Refactor, Validation).

**Characteristics of Each Step:**
- **Red**: Emphasizes clarity and comprehensiveness in test creation.
- **Green**: Minimal implementation and prevention of unintended changes.
- **Refactor**: Balance between improving quality and maintaining functionality.
- **Validation**: Comprehensive quality check and issue discovery.

## Prompt Patterns in AITDD

### Pattern 1: TODO Recording Instruction

A pattern that has the AI record the items to be checked from the generation results in a TODO format.

**Basic Template:**
```markdown
## Example Instruction in a Prompt

Please execute the following process and record the results as a TODO list:

**Content to Execute:**
[Specific instruction content]

**TODO Recording Format:**
```markdown
## [Step Name] Result TODO

### ðŸŸ¢ High Confidence Items
- [ ] [file_name](relative_path) Specific confirmation content

### ðŸŸ¡ Medium Confidence Items
- [ ] [file_name](relative_path) Confirmation of the validity of the inferred content

### ðŸ”´ Judgment Required Items
- [ ] Detailed confirmation: [file_name](relative_path) Organization-specific content
```

**Reference Files:** [List of specified files]
**Output File:** `./todos/[step_name]-check.md`
```

### Pattern 2: Confidence Level Evaluation Instruction

A pattern that has the AI explicitly state the basis and confidence level of the generated content.

**Basic Template:**
```markdown
## Confidence Level Evaluation Instruction

For each generated content, please evaluate the confidence level based on the following criteria:

**Evaluation Criteria:**
- ðŸŸ¢ Green Light: Can be clearly inferred from the reference files.
- ðŸŸ¡ Yellow Light: Reasonable inference but requires confirmation.
- ðŸ”´ Red Light: Generated by independent judgment.

**Evaluation Target:**
1. Each feature of the generated code
2. The reason for selecting the test cases
3. The basis for deciding on the implementation policy

**Output Format:**
- Add a traffic light mark to each item.
- Specify the location in the reference file that serves as the basis.
- Briefly explain the reason for the inference.
```

### Pattern 3: Phased Detailing Instruction

A pattern for proceeding with complex implementations in phases.

**Basic Template:**
```markdown
## Phased Implementation Instruction

Please proceed with the implementation in phases in the following order:

**Phase 1: Basic Structure**
- Minimal operation confirmation
- Skeleton of the main functions/classes
- Basic test cases

**Phase 2: Feature Expansion**
- Specific feature implementation
- Error handling
- Additional test cases

**Phase 3: Optimization**
- Performance improvement
- Code quality improvement
- Comprehensive testing

**Confirmation after each phase:**
- Report of test execution results
- Implementation of confidence level evaluation
- Organization of issues for the next phase
```

## Practical Prompt Components

### Mandatory Element Checklist

Elements that must be included when creating a prompt:

- [ ] **Definition of a clear objective**
  - A clear explanation of what you want to achieve
  - A specific format for the expected output

- [ ] **Specification of reference files**
  - Specifying the files that should be used as a basis
  - Explanation of the relationship between the files

- [ ] **Instruction for confidence level evaluation**
  - Instruction to apply the traffic light system
  - A clear definition of the evaluation criteria

- [ ] **Specification of the output format**
  - Specification of the file name and save location
  - Detailed specification such as markdown format

- [ ] **Specification of constraints and points to note**
  - Parts that should not be changed
  - Special considerations

### Templatable Parts

**Example of a Standard Header:**
```markdown
## [Step Name] Execution Instruction

**Objective:** [Specific objective]
**Reference Files:** [File list]
**Output File:** [Save destination path]

**Confidence Level Evaluation:**
Display the confidence level for each generated content with ðŸŸ¢ðŸŸ¡ðŸ”´.

**Constraints:**
- [Important constraints]
```

### Parts Requiring Customization

Elements that should be customized for each project:

1.  **Domain-specific terms and concepts**
    -   Definition of industry-specific terms
    -   Naming conventions within the project

2.  **Constraints specific to the technology stack**
    -   Constraints of the framework being used
    -   Performance requirements

3.  **Organization-specific rules**
    -   Coding standards
    -   Security guidelines

## Prompt Techniques for Ensuring Quality

### 1. Preventing Unintended Implementations

**Countermeasure Technique:**
```markdown
## Clarification of Implementation Constraints

**Scope of allowed changes:**
- Changeable: [Specific file/function names]
- Not changeable: [Existing working parts]

**Implementation Policy:**
- Achieve the objective with minimal changes
- Minimize the impact on existing features
- Basically add new things, and keep existing modifications to a minimum

**Confirmation Check:**
- [ ] Are there any changes outside the specified scope?
- [ ] Do existing tests continue to succeed?
- [ ] Have no unintended side effects occurred?
```

### 2. Specifying the Relationship with Source Files

**Example of Specifying Relationships:**
```markdown
## Reference File Relationship Diagram

**Primary References:**
- `spec.md` â†’ Basis for requirements definition
- `existing_test.js` â†’ Confirmation of existing specifications
- `config.json` â†’ Reference for configuration specifications

**Derived References:**
- `utils.js` â†’ Utilization of existing utilities
- `types.ts` â†’ Ensuring consistency of type definitions

**Reference Priority During Generation:**
1. Prioritize primary references above all else.
2. If there are contradictions, adopt the primary reference.
3. If anything is unclear, record it clearly as a question.
```

### 3. Implementing Phased Detailing

**Detailing Strategy:**
```markdown
## Phased Detailing Process

**Level 1: Skeleton Creation**
- Interface definition
- Signatures of main functions
- Basic error handling

**Level 2: Feature Implementation**
- Implementation of business logic
- Detailed error handling
- Input value validation

**Level 3: Optimization & Completion**
- Performance optimization
- Handling of edge cases
- Documentationæ•´å‚™

**Checklist for each level:**
- Test execution results
- Confidence level evaluation
- Issues for the next level
```

## Practical Exercises

### Exercise 1: Creating a Basic Prompt

Create a prompt for the following scenario:

**Scenario:** Creating test cases for a user authentication feature
**Reference Files:** `auth_spec.md`, `user_model.js`
**Expected Output:** A test file in Jest format

**Elements to Create:**
1. A clear objective definition
2. Specification of reference files
3. Instruction for confidence level evaluation
4. Specification of the output format

### Exercise 2: Designing a Phased Implementation Prompt

**Scenario:** Implementing a REST API endpoint
**Requirement:** Includes complex data processing
**Constraint:** Utilizes existing middleware

**Elements to Design:**
1. Three implementation phases
2. Deliverables for each phase
3. Confirmation items between phases

## Summary

The core of effective prompt design is as follows:

1.  **Iterative Improvement**: Do not aim for perfection at once; assume continuous improvement.
2.  **Confidence Level Evaluation**: Visualize the AI's inferred parts to achieve efficient reviews.
3.  **Step-by-step Optimization**: Prompt design according to each stage of TDD.
4.  **Quality Control**: Prevention of unintended implementations and clarification of reference sources.

In the next section, we will learn in detail about the AI inference visualization technology that specifically utilizes these principles.
